\section{Quantum Money}
\label{sec:model}

Consider money tokens which consist of a quantum state $\ket{\$_p}$ in
a fixed basis $\{\ket{G}\}$, where the labels are taken from a set
$\{G\}$,
and a classical serial number $p$.
We will use $G$ and $\ket{G}$ interchangeably.
Our scheme also includes a classical function
$A: \{G\} \rightarrow \{p\}$, which defines equivalence
classes $\mathcal{G}_p$ of labels $G$ which map to the same $p$.

\begin{displaymath}
\mathcal{G}_p = \{G: A(G) = p \}
\end{displaymath}

We define a valid money state $\ket{\$_p}$ as a (possibly weighted)
superposition of states from $\mathcal{G}_p$, normalized by some constant
$N$.

\begin{displaymath}
\ket{\$_p} = \frac{1}{\sqrt{N}} \sum_{G \in \mathcal{G}_p} q_G \ket{G}
\end{displaymath}

All probabilities and security properties of our scheme scale
with respect to a security parameter $D \in \mathbb{Z}^+$.
%We would like a different serial number $p$ to be produced each time
%with probability exponentially close to 1 to prevent forgery through
%repetition
%of the minting algorithm.
For each $p$, or even from each
$G \in \mathcal{G}_p$, it should be difficult to find the rest of
$\mathcal{G}_p$ (which would let us forge
a specific $\ket{\$_p}$). We will see later that it is useful to
shape the weights $q_G$ of the superposition, rather than have a uniform
distribution. So how do we make public-key quantum money from this?
